#!/usr/bin/env python
# coding: utf-8

# In[1]:


import sympy as sp
import numpy as np


# ## Regrecao

# In[ ]:


import numpy as np
X = np.array(
    [
        [1, 1],
        [1, 2],
        [1, 3],
        [1, 4],
    ]
)

Y = np.array(
    [
        [2],
        [5],
        [6],
        [20],
    ]
)

np.exp(np.log(Y)) # funcs para exp e ln

np.linalg.inv(X.T.dot(X)).dot(X.T).dot(Y)


# exponencial
# - $y = b_1e^{b_2x}$
# - $\ln{y} = b_2x + \ln{b_1}$
# 
# outra
# - $y = b_1*x^{b_2}$
# - $\ln{y} = \ln{b_1} + b_2\ln{x}$

# ## Maximo e minimo 
# 
# Encontrar as primeiras derivadas em relaÃ§Ã£o a x e y, resolver um sistema onde as equaÃ§oes sÃ£o iguais a 0
# - H(x, y) > 0, f_xx > 0 MINIMO
# - H(x, y) > 0, f_xx <> 0 MAXIMO
# - H(x, y) < 0 SELA

# ## Newton-rapson
# - `eq_newton = x - eq/eq.diff(x)`

# In[ ]:





# ## Numeric x Symbolic
# - Numeric computation
#     - Numeric computation concerns finite decimal numbers. It cant represent symbols or values that are non-periodic tithe. That whay it cant be used to solve equations algebraically
#     - $\sqrt{2} \approx 1.41421356$, aq square root of 2 will be represented as its numerical aproximation calculation purpuses, that means that  $\sqrt{2}^{2}$ wont be exacly 2
# - Symbolic computation
#     - Symbolic computation concernes representing numbers as symbols satisfying mathematical rules. That enables it to solve algebra problems
#     - For exemple $\sqrt{2}$ is defined by the relation $\sqrt{2}^{2} = 2$

# In[6]:


np.sqrt(2) ** 2 ## Numeric computation


# In[7]:


sp.sqrt(2) ** 2 ## Symbolic computation


# ## Sympy

# ### Defining Symbols
# - Symbols are the variables for owr equation, to define a symbol with sympy the object `Symbol` is used
# - To define multiple symbols `symbols` is used

# In[10]:


x = sp.Symbol('x')
x


# In[2]:


x, y = sp.symbols('x y')
y


# In[25]:


# To define multiple variables (x1, x2, x3)
x_v = sp.symbols('x1:4')
x_v


# In[12]:


# Defining a simple expression
2*x + 5


# ### Simplification and expanssion

# In[14]:


# Sometimes SymPy expressions are automatically simplified
2*x + x - 5
# Addition, subtraction, multiplication and division are (usually) simplified


# In[15]:


# To expand a expression, the method expand is used
expr = x*(x+2)
expr.expand()


# In[16]:


sp.expand(expr)


# In[22]:


poly = x*(y + 2)*(x - 3)
poly.expand()


# ### Factor Expressions

# In[23]:


expr = x**2 +2*x - 15
expr.factor()


# In[27]:


ex = x_v[0]**2 * x_v[1] * x_v[2] + x_v[0] * x_v[1] * x_v[2]
ex


# In[28]:


ex.factor()


# ### Defining expressions Symbolic
# - For that we need the SymPy functions and data types

# In[30]:


ex_numeric = x**(1/3)
ex_numeric ## (1/3) was evaluatted as a absolute value not as a symbol, this wont alow us to solve equations agebreticaly


# In[31]:


ex_symbolic = x ** (sp.Integer(1) / sp.Integer(3))
ex_symbolic


# ### Data types

# In[32]:


# Integer
integer = sp.Integer(3)
print(integer)

# Rational
rational = sp.Rational(1, 3)
print(rational)

# Imaginary unit
sp.I

## Constants
# pi
sp.pi

# e
sp.E

# Infinity
sp.oo



# ### Functions

# In[39]:


# Exponential
sp.exp(x)


# In[38]:


# Logarithm
sp.log(x)


# In[40]:


# Trigonometric
sp.sin(x)
sp.cos(x)
sp.tan(x)


# ### Solving Equations

# In[41]:


x, y, z = sp.symbols('x y z')


# In[42]:


# Defome the equation
eq = sp.Eq(x**2, 5)
eq


# In[45]:


sp.solveset(eq, symbol=x)


# In[47]:


# Second exemple
eq2 = sp.Eq(sp.cos(x)-sp.sin(x), 0)
eq2


# In[48]:


sp.solveset(eq2)


# In[49]:


# Third Exemple (non-solvable)
eq3 = sp.Eq(sp.cos(x), x)
eq3


# In[50]:


sp.solveset(eq3)
# Need to find the solution numerically


# ### Solving a System of linear equations

# In[3]:


import sympy as sp
x, y, z = sp.symbols('x y z')
eq1 = sp.Eq(x, 3*y + z)
eq1


# In[9]:


eq2 = sp.Eq(x*5 - 3*z, y)
eq2


# In[10]:


sp.linsolve([eq1, eq2], x, y, z)


# In[12]:


eq3 = sp.Eq(x**2, z*12)


# In[13]:


sp.nonlinsolve([eq1, eq2, eq3], x, y, z)


# ### Simplifyng Expressions
# - Functions
#     - `sp.factor()` - Factors the expression
#     - `sp.expand()` - Expand expressions
#     - `sp.cancel()` - Puts rational functions in standar canonical form
#     - `sp.apart()` - Performs a partial fraction decomposition for a function
#     - `sp.simplify()` - A general simplification function

# In[54]:


x, y = sp.symbols('x y')


# In[57]:


poly1 = x **2 + 5*x + 6
poly1


# In[58]:


poly1 = poly1.factor()
poly1


# In[59]:


poly1.expand()


# In[60]:


sp.exp(x + y)


# In[61]:


sp.exp(x + y).expand()


# In[62]:


trig = (sp.cos(x) + sp.sin(y))**2 - sp.cos(x)**2
trig


# In[63]:


trig.expand()


# In[64]:


p = x**3 + 10 * x**2 + 31 * x + 30
q = x**2 + 12 * x + 35
fraq = p/q
fraq


# In[65]:


fraq.cancel()


# In[66]:


fraq.apart()


# ### Define type for symbos

# In[ ]:


x_real = sp.Symbol('x', real=True)

x_positive = sp.Symbol('x', positive=True)

x_integer = sp.Symbol('x', integer=True)


# ### Point evaluation of expression
# - To solve a equation for a fixed value of a variable, SymPy uses `.subs()` method

# In[67]:


expr = x**2 + 5
expr


# In[70]:


print(expr.subs(x, 2))
print(expr.subs(x, sp.pi))


# In[71]:


# .subs() can awso be used to insert a second equation inside the original
expr.subs(x, y**5 + 3)


# ### Going Numeric
# - Is possible to transform a SymPy constant into decimal with the `sp.N()` function

# In[72]:


sp.N(expr.subs(x, sp.pi))


# In[74]:


expr = sp.pi + x**2
print(expr)
sp.N(expr)


# ### Derivatives

# In[76]:


expr = sp.exp(2*x) + sp.sin(x)
expr


# In[79]:


first_derivative = sp.diff(expr, x)


# In[81]:


second_derivetive = sp.diff(expr, x, x)
second_derivetive


# In[82]:


second_derivetive = sp.diff(expr, x, 2)
second_derivetive


# ### Rewriting Functions
# - To rewrite a function in terms of another function, is possible to use the `.rewrite()` method

# In[3]:


expr = sp.exp(sp.sinh(x))/sp.exp(sp.exp(x)/2)
expr


# In[4]:


expr2 = expr.rewrite(sp.exp)
expr2


# In[6]:


expr2.simplify()


# ### Rewriting and Partial Derivatives
# - The rewrite function can be helpful to get the partial derivative in a specified form.

# In[7]:


multi_variable = sp.cos(x) * sp.cot(2 * y)**2
multi_variable


# In[8]:


partial_y = multi_variable.diff(y)
partial_y


# In[9]:


simpl_partial_y = partial_y.simplify()
simpl_partial_y


# In[10]:


simpl_partial_y.rewrite(sp.sin)


# In[11]:


multi_variable.diff(x, y)


# ### Limits

# In[12]:


expr = x**2
expr.limit(x, 1)


# In[14]:


expr.subs(x, 1)


# In[15]:


expr = x/sp.exp(x)
expr


# In[16]:


sp.limit(expr, x, sp.oo)


# #### Left, right limits

# In[17]:


expr = 1/x
expr


# In[18]:


sp.limit(expr, x, 0) ## Will be the right limit, by default


# In[19]:


sp.limit(expr, x, 0, '-')


# In[20]:


sp.limit(expr, x, 0, '+-')


# ### Going numerical

# In[21]:


expr = sp.pi * x**2 + 5*x + sp.E
expr


# In[22]:


value = expr.subs(x, 1)
value ## not numerical


# In[23]:


value.evalf() ## Numerical


# In[ ]:


value.evalf(8) ## Round


# In[24]:


sp.N(value, 8)


# - `.evalf()` can be realy slow. To evaluate many points (to create a plot for exemple) `.lambdify()` is used. It sorts of create a function that recives a value for the variables (point) and returns the result.

# In[25]:


lambdified_expr = sp.lambdify(x, expr)
lambdified_expr


# In[26]:


lambdified_expr(3)


# In[27]:


points = np.linspace(-20, 20, 1000)
points


# In[29]:


results = lambdified_expr(points)
results


# In[30]:


import matplotlib.pyplot as plt

plt.plot(points, results)
plt.title('Parabola')
plt.show()

